using Microsoft.CodeAnalysis;
using System.Linq;
using System.Collections.Immutable;
using System.Collections.Generic;

namespace FizzBuzz.SourceGenerator
{
    internal static class Generator
    {
        public static string CreateTypeSourceCode(TypeDefinition definition)
        {
            return string.Join("\r\n", FormatType(definition));
        }

        private static IEnumerable<string> FormatType(TypeDefinition definition)
        {
            yield return  "//<auto-generated/>";
            yield return "#nullable enable";

            yield return $"using global::System;";

            yield return $"namespace {definition.Namespace}";
            yield return "{";

            yield return $"\tpartial class {definition.TypeName}";
            yield return "\t{";
            
            yield return $"\t\tpublic partial string {definition.MethodName}(global::System.Int32 value)";
            yield return "\t\t{";

            foreach (var line in FormatSwitchStatement(definition.Options))
            {
                yield return $"\t\t\t{line}";
            }

            yield return "\t\t}";

            yield return "\t}";

            yield return "}";
        }

        private static IEnumerable<string> FormatSwitchStatement(IReadOnlyList<OptionDefinition> options)
        {
            var moduloOptions = options.Select(op => $"value % {op.Divider}");
            yield return $"return ({string.Join(", ", moduloOptions)}) switch";
            yield return "{";

            foreach (var line in GenLines(options))
            {
                yield return $"\t{line},";
            }

            yield return "};";
        }


        private static IEnumerable<string> GenLines(IReadOnlyList<OptionDefinition> options)
        {
            var emptyStack = ImmutableArray<(char, string)>.Empty;
            return Enumerable.Union(
                GenLines(options, 0, true, emptyStack),
                GenLines(options, 0, false, emptyStack));
        }

        private static IEnumerable<string> GenLines(IReadOnlyList<OptionDefinition> options, int currentIndex, bool isZero, ImmutableArray<(char, string)> stack)
        {

            if (currentIndex < options.Count)
            {
                var (val, text, _) = options[currentIndex];

                var nextStackEntry = isZero ? ('0', text) : ('_', string.Empty);
                var nextStack = stack.Add(nextStackEntry);
                var nextIndex = currentIndex + 1;

                return Enumerable.Union(
                    GenLines(options, nextIndex, true, nextStack),
                    GenLines(options, nextIndex, false, nextStack));
            }
            else
            {
                return new[] { FormatLineFromStack(stack) };
            }
        }


        private static string FormatLineFromStack(ImmutableArray<(char, string)> stack)
        {
            var matchingSequence = string.Join(", ", stack.Select(n => n.Item1));
            var resultSequence = string.Concat(stack.Select(n => n.Item2));

            return string.IsNullOrEmpty(resultSequence)
                ? $"({matchingSequence}) => value.ToString()"
                : $"({matchingSequence}) => \"{resultSequence}\"";
        }

    }



}


